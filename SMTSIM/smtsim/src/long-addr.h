// -*- C++ -*-
//
// "Long address", address plus address-space-ID bundle
//
// Jeff Brown
// $Id: long-addr.h,v 1.1.4.10 2009/08/08 22:13:58 jbrown Exp $
//

// Note: this requires definitions sys-types.h to be visible.  We don't
// include sys-types.h here, since we'll probably include long-addr.h /from/
// sys-types.h.

#ifndef LONG_ADDR_H
#define LONG_ADDR_H

typedef struct LongAddr LongAddr;

// Abstraction of a virtual address + address space ID + etc.  This is meant
// to be a compact, bare-bones structure, compatible with C, using only
// "value" semantics.
//
// (It seems silly to devote so much space to such a simple thing, but
// previously we used to sling these values around as independent function
// arguments in many places; we might as well bundle them up, for
// consistency.)

#ifdef __cplusplus
#include <string>
#endif  // __cplusplus

struct LongAddr {
    // Register-sized virtual address bits, as generated by instructions
    u64 a;

    // Address-space identifier ("master_id" in many parts of the simulator).
    // Two LongAddrs refer to the same storage iff they have equal "a" and
    // "id" fields.  This can be thought of as additional higher-order bits to
    // the left of "a".  Something like this would typically be managed by the
    // OS, perhaps stored in the TLBs, and transparently included in
    // virtual address translation and tag matching.
    u32 id;

#ifdef __cplusplus
    // C++ convenience methods, operating on the same storage as C code.
    // (It's critical that there are no virtual functions or anything fancy
    // like that, lest the C structure layout disagree.  We test for this.)
    LongAddr() { }
    LongAddr(u64 a_, u32 id_) : a(a_), id(id_) { }
    void set(u64 a_, u32 id_) { a = a_, id = id_; }
    void clear() { a = 0; id = 0; }
    bool operator < (const LongAddr& a2) const {
        return (id < a2.id) || ((id == a2.id) && (a < a2.a));
    }
    bool operator == (const LongAddr& a2) const {
        return (a == a2.a) && (id == a2.id);
    }
    // I've not used "operator bool()" for the nonzero test, since that
    // makes it too easy to accidentally say "u64 my_address = some_longaddr;"
    bool nonzero() const { return a != 0; }
    size_t stl_hash() const {
        StlHashU64 h;      // from sys-types.h; may be identity
        return h(a ^ (static_cast<u64>(id) << 32));
    }
    size_t hash() const {
        HashU64 h;
        return h(a ^ (static_cast<u64>(id) << 32));
    }
    // Returns some string suitable for debug printing, reporting, etc.
    // (Implemented in sys-types.cc; equivalent to fmt_laddr())
    std::string fmt() const;
#endif  // __cplusplus
};


#ifdef __cplusplus
extern "C" {
#endif
    // These live in sys-types.cc
    const char *fmt_laddr(LongAddr addr);
    size_t hash_laddr(LongAddr addr);

    // This currently lives in long-addr-c.c; it's used for internal
    // consistency checking within systypes_init().
    extern int SizeOfLongAddrFromC;
#ifdef __cplusplus
}       // extern "C"
#endif


// Macros suck, but C++/C99/etc. don't want to play nice together when it
// comes to inline function syntax/definition.  The "_set" function/macro is
// provided to avoid leaving behind uninitialized fields: if the structure
// is changed and the macro updated with additional arguments, existing
// uses of it will fail until something is filled in.

#define laddr_eq(a1, a2) (((a1).a == (a2).a) && ((a1).id == (a2).id))
#define laddr_lt(a1, a2) (((a1).id < (a2).id) || \
                          (((a1).id == (a2).id) && ((a1).a < (a2).a)))
#define laddr_set(la, a_, id_) \
    do { (la).a = (a_); (la).id = (id_); } while (0)
#define laddr_clear(la) do { (la).a = 0; (la).id = 0; } while (0)
#define laddr_nonzero(la) ((la).a != 0)


#endif  /* LONG_ADDR_H */
